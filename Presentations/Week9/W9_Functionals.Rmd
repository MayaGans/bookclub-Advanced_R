---
title: "map_shiny(v,fun)"
author: "Tan Ho (@_TanHo)"
date: "28/05/2020"
output: 
  learnr::tutorial:
        css: css/styles.css
        toc: true
        toc_depth: 2
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

suppressPackageStartupMessages({
  # Data Import
  library(arrow)
  library(here)
  
  # Data manip
  library(tidyverse)
  
  # Shiny
  library(shiny)
  library(shinydashboard)
  library(shinyWidgets)
  library(learnr)
  
})

```

## AdvR Book Club Ch 9 - Functionals

[\@_TanHo](https://twitter.com/_TanHo)

2020-05-28


## Intro

So lately we've been doing a lot of chapter recaps in these presentations, but...

![](images/shiny_meme.jpg)


This time, let's build  a beer reviews app in Shiny!

Along the way, we'll try to find (minimally contrived) opportunities to use: 

  * map and friends like map2/pmap, lgl/chr/dbl
  * walk
  * modify
  * reduce

Some prerequisite assumptions I'm making here: 

  1. You've already read chapter 9 in the Adv R book (and/or)
  
  2. You've read ch21 of R4DataScience (i.e. the chapter on purrr) (and/or)
  
  3. You have some familiarity with purrr, lapply, or loops
  
  4. You've heard of the glorious Shiny (it's okay if you haven't built an app before!)


I'll be live-coding this, so feel free to chime in with suggestions, critiques, and (frequent) reminders about forgetting parentheses () !


## Dataset Overview

I first came across the Beer Reviews dataset from watching one of [Nick Wan](http://twitter.com/nickwan)'s Twitch streams, in which he does some really awesome live-code and data science. 

From the Kaggle notes:

> This data comes from BeerAdvocate and spans 10+ years of beer reviews on their platform up until Nov 2011, including ~1.5 million reviews. Each review includes ratings in terms of five "aspects": appearance, aroma, palate, taste, and overall impression. Reviews include product and user information, followed by each of these five ratings, and a plaintext review.

While Nick dove down the datasci rabbithole with PCA, clustering, and recommender models, for today's purposes we'll be building a tool that collects beer ratings from users (i.e. you guys!) and compares your reviews with the reviews from the dataset!

I ***think *** that I can do Shiny app components in the {learnr} package, so we'll give that a spin first. If that doesn't work out, I can always open up a fresh RStudio window `r emo::ji('sunglasses')`

Here's what my setup chunk looks like and a brief skim of the raw data:

```{r packages_and_data, echo = TRUE}

suppressPackageStartupMessages({
  # Data Import
  library(arrow)
  library(here)
  
  # Data manip
  library(tidyverse)
  
  # Shiny
  library(shiny)
  library(shinydashboard)
  library(shinyWidgets)
  library(learnr)
  
})

# Read data in via arrow for much fast
beer_reviews <- arrow::read_parquet(file = here::here("data/beer_reviews.pdata")) 

# What does this data look like?
beer_reviews %>%
  sample_n(10) %>% 
  str()
```

## Game Plan

I've roadmapped a few features that I'd like to try to include (and should help demonstrate some FUNctionals)

1. Dynamically generate a review form for each beer selected from a picker (*using map*)
2. Add some filters to the select option so we can quickly find beers by type, ABV, and average rating (*map/reduce*)
3. Read back the ratings from the user! (*map lgl/chr/dbl/int*)
4. Convert to z-scores to better compare rankings (*modify*)
5. Write reviews to one csv per brewery (*walk*)

## Data Cleaning

I've gone ahead and done a little bit of pre-emptive data cleaning `r emo::ji('broom')` to help us just focus on the functionals in the app session later.

```{r data, context = "data"}

breweries <- beer_reviews %>% 
  group_by(brewery_id,brewery_name) %>% 
  summarise(
    review_count = n(),
    review_avg = mean(review_overall,na.rm=TRUE),
    review_sd = sd(review_overall,na.rm = TRUE),
    beer_count = length(unique(beer_beerid)),
    beer_styles = paste0(unique(beer_style),collapse = ", "),
    beer_list = list(unique(beer_name))
  ) %>% 
  ungroup()

beers <- beer_reviews %>% 
  group_by(review_profilename) %>%   # Scaling reviews by reviewer
  mutate(reviewer_avg = mean(review_overall,na.rm = TRUE),
         reviewer_sd = sd(review_overall,na.rm = TRUE),
         reviewer_z = (review_overall - reviewer_avg)/reviewer_sd
         ) %>% 
  ungroup() %>% 
  group_by(brewery_id,brewery_name,beer_style,beer_id = beer_beerid, beer_name, beer_abv) %>% 
  summarise(
    review_count = n(),
    review_avg = mean(review_overall,na.rm = TRUE),
    review_z = sum(reviewer_z,na.rm = TRUE)
  ) %>% 
  ungroup()

breweries %>%
  sample_n(10)

beers %>%
  sample_n(10)

```


## 1 - Generate inputs

## 2 - Add dynamic filters

## 3 - Read back inputs

## 4 - Convert to z-scores

## 5 - Write to csv

## CHEERS

Cheers, folks! `r emo::ji('beers')` 

That's all I had roadmapped - questions? Other cool ideas to tackle?

I've attached a prototype version of this app I made into the Presentations/Week9 folder and it should run standalone (provided you have the requisite packages, of course `r emo::ji('box')`)

