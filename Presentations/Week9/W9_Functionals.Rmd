---
title: "map_shiny(v,fun)"
author: "Tan Ho (@_TanHo)"
date: "28/05/2020"
output: 
  learnr::tutorial:
        css: css/styles.css
        toc: true
        toc_depth: 2
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(shiny)
library(learnr)
library(knitr)

```

## AdvR Book Club Ch 9 - Functionals

[\@_TanHo](https://twitter.com/_TanHo)

2020-05-28


## Intro

So lately we've been doing a lot of chapter recaps in these presentations, but...

![](images/shiny_meme.jpg)


This time, let's build  a beer reviews app in Shiny!

Along the way, we'll try to find (minimally contrived) opportunities to use: 

  * map and friends like map2/pmap, lgl/chr/dbl
  * walk
  * modify
  * reduce

Some prerequisite assumptions I'm making here: 

  1. You've already read chapter 9 in the Adv R book (and/or)
  
  2. You've read ch21 of R4DataScience (i.e. the chapter on purrr) (and/or)
  
  3. You have some familiarity with purrr, lapply, or loops
  
  4. You've heard of the glorious Shiny (it's okay if you haven't built an app before!)


I'll be live-coding this, so feel free to chime in with suggestions, critiques, and (frequent) reminders about forgetting parentheses () !


## Dataset Overview

This data comes from BeerAdvocate and spans 10+ years of beer reviews on their platform up until Nov 2011, including ~1.5 million reviews. Each review includes ratings in terms of five "aspects": appearance, aroma, palate, taste, and overall impression. Reviews include product and user information, followed by each of these five ratings, and a plaintext review.

I first came across this dataset from watching one of [Nick Wan's live-coding Twitch streams](http://twitter.com/nickwan) where he does some really cool live code and modelling (unfortunately, he does his coding in Python, but we can't all be perfect!). He had a "recommender model" which did some clustering and similarity scores, so that he could get the model to output "ten beers to try" if you happened to like a specific beer. 

I don't think 

The goal of today's app is to build something that'll collect beer rankings from users (i.e. you guys!) and then compare your reviews with the reviews from the dataset! 

I ***think *** that I can do Shiny app components in the {learnr} package, so we'll give that a spin first but if that doesn't work out, I can always open up a fresh RStudio window to do this `r emo::ji('sunglasses')`

```{r packages_and_data, echo = TRUE}

suppressPackageStartupMessages({
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(shiny)
library(learnr)
library(arrow)
library(here)
})

beer_reviews <-read_parquet(file = here("data/beer_reviews.pdata")) 
# read in parquet file from repository

head(beer_reviews)

```

## Game Plan

Some fun features we'll try: 

1. 
2. 
3. 
4. 
5. 

## Data Cleaning



## PART ONE: CREATE INPUTS

## PART TWO: RETURN INPUTS

## PART THREE: ???

## PROFIT

## random shiny demo

You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.

```{r eruptions, echo=FALSE, eval = FALSE}
inputPanel(
  selectInput("n_breaks", label = "Number of bins:",
              choices = c(10, 20, 35, 50), selected = 20),
  
  sliderInput("bw_adjust", label = "Bandwidth adjustment:",
              min = 0.2, max = 2, value = 1, step = 0.2)
)

renderPlot({
  hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
       xlab = "Duration (minutes)", main = "Geyser eruption duration")
  
  dens <- density(faithful$eruptions, adjust = input$bw_adjust)
  lines(dens, col = "blue")
})

```