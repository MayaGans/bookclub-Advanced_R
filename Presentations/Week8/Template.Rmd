---
title: "Chapter 8: Conditions"
subtitle: "Maya Gans"
author: "R4DS Reading Group"
output:
  xaringan::moon_reader:
    nature:
      highlightLines: true
    lib_dir: libs
    css: xaringan-themer.css
    includes:
      after_body: insert-logo.html
---


```{r xaringan-themer, include = FALSE}
library(xaringanthemer)
library(tidyverse)
mono_light(
  base_color = "#3092FF",
  header_font_google = google_font("Josefin Slab"),
  text_font_google   = google_font("Raleway", "300", "300i")
)
```


# Overview

- Signaling conditions
  - Error
  - Warning
  - Message
- Ignoring conditions
 - try
 - suppress Warning/Message
- Handling conditions
 - tryCatch
 - withCallingHandlers
- Custom conditions


```{r, warning=FALSE, message=FALSE}
beer_states <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-03-31/beer_states.csv')
```


---

class: inverse, hide-logo
# Signaling Conditions 

- Error
- Warning
- Message

---

# Errors

> "An error message should start with a general statement of the problem then give a concise description of what went wrong. Consistent use of punctuation and formatting makes errors easier to parse. 

> (This guide is currently almost entirely aspirational; most of the bad examples come from existing tidyverse code.)"

.footnote[
https://style.tidyverse.org/error-messages.html
]

---

## stop

```{r, eval=FALSE}
beer_mean <- function(x) {
  if (!is.numeric(x)) {
    stop("Need numeric column", call.=FALSE) #<<
    mean(data[[x]])
  } else{
    mean(x)
  }
}

beer_mean(beer_states$state)
```

```
Error: Need numeric column
   2. stop("Need numeric column", call. = FALSE)
   1. beer_mean(beer_states$state)
```

---

## abort

```{r, eval=FALSE}
beer_mean <- function(x) {
  if (!is.numeric(x)) {
    abort( #<<
      message = "Need numeric column", #<<
      arg = x #<<
      ) #<<
    mean(data[[x]])
  } else{
    mean(x)
  }
}

beer_mean(beer_states$state)
```

```
Error: Need numeric column
   4. stop(fallback)
   3. signal_abort(cnd)
   2. abort(message = "Need numeric column", arg = x)
   1. beer_mean(beer_states$state)
```

---

## abort + glue

```{r, eval=FALSE}
beer_mean <- function(data, x) {
  
  column_name <- deparse(substitute(x))
  
  msg <- glue::glue("Can't calculate mean, {column_name} is not numeric")
  
  if (!is.numeric(data[[x]])) {
    abort(
      message = msg, #<<
      arg = column_name, #<<
      data = data #<<
    )
    mean(data[[x]])
  } else {
    mean(data[[x]])
  }
}
```

```{r, eval=FALSE}
beer_mean(beer_states, "state")
```


```
Error: Can't calculate mean, "state" is not numeric
Run `rlang::last_error()` to see where the error occurred. 
   4. stop(fallback) 
   3. signal_abort(cnd) 
   2. abort(message = msg, arg = column_name, data = data) 
   1. beer_mean(beer_states, "state") 
```

---

# abort metadata

```{r, eval=FALSE}
str(catch_cnd(beer_mean(beer_states, "state")))
```

```{r, eval=FALSE}
[1] "\"state\""
List of 5
 $ message: 'glue' chr "Can't calculate mean, \"state\" is not numeric" #<<
 $ trace  :List of 4
 ...
 $ parent : NULL
 $ arg    : chr "\"state\"" #<<
 $ data   : tibble [1,872 × 4] (S3: spec_tbl_df/tbl_df/tbl/data.frame) #<<
  ..$ state  : chr [1:1872] "AK" "AK" "AK" "AK" ...
  ..$ year   : num [1:1872] 2008 2009 2010 2011 2012 ...
  ..$ barrels: num [1:1872] 2068 2264 1929 2251 2312 ...
  ..$ type   : chr [1:1872] "On Premises" "On Premises" "On Premises" "On Premises" ...
  ..- attr(*, "spec")=
  .. .. cols(
  .. ..   state = col_character(),
  .. ..   year = col_double(),
  .. ..   barrels = col_double(),
  .. ..   type = col_character()
  .. .. )
 - attr(*, "class")= chr [1:3] "rlang_error" "error" "condition"
```

---

# Warnings

> Warnings occupy a somewhat challenging place between messages (“you should know about this”) and errors (“you must fix this!”)

_Not shown: mutating the year column to a date type, creating an `is.Date` function to check for date types. See .Rmd for code_

```{r, echo=FALSE}
beer_states <- 
  beer_states %>% 
  mutate(year = lubridate::ymd(year, truncated = 2L))

is.Date <- function(x) {
  inherits(x, c("Date", "POSIXt"))
}
```

```{r, eval=FALSE}
beer_mean <- function(data, x) {
  
  column_name <- deparse(substitute(x))
  
  if (is.Date(data[[x]])) {
    warning(glue::glue("Are you sure you wanna calculate the mean? {column_name} is of type date")) #<<
    mean(data[[x]])
  } else {
    mean(data[[x]])
  }
}

beer_mean(beer_states, "year")
```

```
[1] "2013-07-02"
Warning message:
In beer_mean(beer_states, "year") :
  Are you sure you wanna calculate the mean? "year" is of type date
```

---

# Messages

>Good messages are a balancing act: you want to provide just enough information so the user knows what’s going on, but not so much that they’re overwhelmed.

## message
quiet = true

```{r}
beer_sd <- function(data, x) {
  
  column_name <- deparse(substitute(x))
  
  if (is.Date(data[[x]])) {
    message(glue::glue("Are you sure you wanna calculate the mean? {column_name} is of type date")) #<<
    mean(data[[x]])
  } else {
    mean(data[[x]])
  }
}

beer_mean(beer_states, "year")
```


## packageStartupMessage

---

class: inverse, hide-logo
# Ignoring Conditions

---

# try

---

# suppress

---

class: inverse, hide-logo
# Handling Conditions 

---

# tryCatch

---

# withCallingHandlers

---


<style>
pre {
  font-size: 11px;
}
</style>