---
title: "Chapter 8: Conditions"
subtitle: "Maya Gans"
author: "R4DS Reading Group"
output:
  xaringan::moon_reader:
    nature:
      highlightLines: true
    lib_dir: libs
    css: xaringan-themer.css
    includes:
      after_body: insert-logo.html
---


```{r xaringan-themer, include = FALSE}
library(xaringanthemer)
library(tidyverse)
library(rlang)
library(gt)
mono_light(
  base_color = "#3092FF",
  header_font_google = google_font("Josefin Slab"),
  text_font_google   = google_font("Raleway", "300", "300i")
)
```


# Overview

- Signaling conditions
  - Error
  - Warning
  - Message
- Ignoring conditions
 - try
 - suppress Warning/Message
- Handling conditions
 - tryCatch
 - withCallingHandlers

```{r, warning=FALSE, message=FALSE}
brewing_materials <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-03-31/brewing_materials.csv')
beer_taxed <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-03-31/beer_taxed.csv')
brewer_size <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-03-31/brewer_size.csv')
beer_states <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-03-31/beer_states.csv')
```


---

class: inverse, hide-logo
# Signaling Conditions 

- Error
- Warning
- Message

---

# Errors

> "An error message should start with a general statement of the problem then give a concise description of what went wrong. Consistent use of punctuation and formatting makes errors easier to parse. 

> (This guide is currently almost entirely aspirational; most of the bad examples come from existing tidyverse code.)"

.footnote[
https://style.tidyverse.org/error-messages.html
]

---

## stop

```{r, eval=FALSE}
beer_mean_error <- function(x) {
  if (!is.numeric(x)) {
    stop("Need numeric column", call.=FALSE) #<<
    mean(which(!is.na(x)[x]))
  } else{
    mean(which(!is.na(x)[x]))
  }
}

beer_mean_error(beer_states$states)
```

```
Error: Need numeric column
   2. stop("Need numeric column", call. = FALSE)
   1. beer_mean(beer_states$state)
```

---

## `rlang::abort`

```{r, eval=FALSE}
beer_mean_abort <- function(x) {
  if (!is.numeric(x)) {
    abort( #<<
      message = "Need numeric column", #<<
      arg = x #<<
      ) #<<
    mean(which(!is.na(x)[x]))
  } else{
    mean(which(!is.na(x)[x]))
  }
}

beer_mean_abort(beer_states$state)
```

```
Error: Need numeric column
   4. stop(fallback)
   3. signal_abort(cnd)
   2. abort(message = "Need numeric column", arg = x)
   1. beer_mean(beer_states$state)
```

---

## abort + glue

```{r}
beer_mean_abort <- function(data, x) {
  
  column_name <- deparse(substitute(x))
  
  msg <- glue::glue("Can't calculate mean, {column_name} is not numeric")
  
  if (!is.numeric(data[[x]])) {
    abort(
      message = msg, #<<
      arg = column_name, #<<
      data = data #<<
    )
    mean(which(!is.na(data[[x]])[data[[x]]]))
  } else {
    mean(which(!is.na(data[[x]])[data[[x]]]))
  }
}
```

```{r, eval=FALSE}
beer_mean_abort(beer_states, "state")
```


```
Error: Can't calculate mean, "state" is not numeric
Run `rlang::last_error()` to see where the error occurred. 
   4. stop(fallback) 
   3. signal_abort(cnd) 
   2. abort(message = msg, arg = column_name, data = data) 
   1. beer_mean(beer_states, "state") 
```

---

# abort metadata

```{r, eval=FALSE}
str(catch_cnd(beer_mean_abort(beer_states, "state")))
```

```{r, eval=FALSE}
[1] "\"state\""
List of 5
 $ message: 'glue' chr "Can't calculate mean, \"state\" is not numeric" #<<
 $ trace  :List of 4
 ...
 $ parent : NULL
 $ arg    : chr "\"state\"" #<<
 $ data   : tibble [1,872 × 4] (S3: spec_tbl_df/tbl_df/tbl/data.frame) #<<
  ..$ state  : chr [1:1872] "AK" "AK" "AK" "AK" ...
  ..$ year   : num [1:1872] 2008 2009 2010 2011 2012 ...
  ..$ barrels: num [1:1872] 2068 2264 1929 2251 2312 ...
  ..$ type   : chr [1:1872] "On Premises" "On Premises" "On Premises" "On Premises" ...
  ..- attr(*, "spec")=
  .. .. cols(
  .. ..   state = col_character(),
  .. ..   year = col_double(),
  .. ..   barrels = col_double(),
  .. ..   type = col_character()
  .. .. )
 - attr(*, "class")= chr [1:3] "rlang_error" "error" "condition"
```

---

# Warnings

> Warnings occupy a somewhat challenging place between messages (“you should know about this”) and errors (“you must fix this!”)

```{r, echo=FALSE}
beer_states <- 
  beer_states %>% 
  mutate(year = lubridate::ymd(year, truncated = 2L))

is.Date <- function(x) {
  inherits(x, c("Date", "POSIXt"))
}
```

```{r, eval=FALSE}
beer_mean_warning <- function(data, x) {
  
  column_name <- deparse(substitute(x))
  
  if (is.Date(data[[x]])) {
    warning(glue::glue("Are you sure you wanna calculate the mean? {column_name} is of type date")) #<<
    mean(which(!is.na(data[[x]])[data[[x]]]))
  } else {
    mean(which(!is.na(data[[x]])[data[[x]]]))
  }
}

beer_mean(beer_states, "year")
```

```
[1] "2013-07-02"
Warning message:
In beer_mean(beer_states, "year") :
  Are you sure you wanna calculate the mean? "year" is of type date
```

.footnote[
_Not shown: (1) mutating the year column to a date type, (2) creating an `is.Date` function to check for date types. See .Rmd for code_
]

---

# Messages

>Good messages are a balancing act: you want to provide just enough information so the user knows what’s going on, but not so much that they’re overwhelmed.

```{r}
basic_summary_stats <- function(data, x, round_n = NULL, quiet = FALSE) {
  
  if (!is.numeric(data[[x]])) abort(glue::glue("Need numeric value to calculate stats and {x} is categorical"))
  if (is.null(round_n)) {
    
    if (isFALSE(quiet)) message("round_n argument null, rounding to 2 digits by default") #<<
    
    data %>% 
      summarise(
        missing = sum(is.na( data[[x]] )),
        mean = round(mean(which(!is.na(data[[x]])[data[[x]]])), 2)
       )
  } else {
    data %>% 
      summarise(
        missing = sum(is.na( data[[x]] )),
        mean = round(mean(which(!is.na(data[[x]])[data[[x]]])), round_n)
       )
  }
}

```

.pull-left[
```{r}
basic_summary_stats(beer_states, "barrels")
```
]

.pull-right[
```{r}
basic_summary_stats(beer_states, "barrels", quiet = TRUE)
```
]

---

class: inverse, hide-logo
# Ignoring Conditions

- try
- suppressMessage

---

# try

```{r, eval=FALSE}
beer_mean_try <- function(data, x) {
  try(data[[x]]) #<<
  NA
}

beer_mean_try(beer_states, "states")
```

```
[1] NA
```

---

# suppressMessages

```{r, eval=FALSE}
testthat::test_that("beer mean function works", {
  
  # calculate mean using base and round to two digits
  base_mean <- round(mean(which(!is.na(beer_states$barrels)[beer_states$barrels])), 2)
  
  # use our function and suppress warning since we're not supplying a rounding argument
  suppressMessages( #<<
    our_function <- basic_summary_stats(beer_states, "barrels") %>% pull(mean) #<<
  ) #<<
  
  # test that they are equal
  testthat::expect_equal(base_mean, our_function)
  # test that our function will produce a message
  testthat::expect_message(basic_summary_stats(beer_states, "barrels") %>% pull(mean))
})
```

.footnote[
_My thoughts behind this were that we don't want to clutter the output log when we run all our tests, but is this really best practice?_
]

---

class: inverse, hide-logo
# Handling Conditions 

- tryCatch
- withCallingHandlers

---

# tryCatch

```{r, eval=FALSE}
beer_mean_tryCatch <- function(expr) {
  tryCatch(
    error = function(cnd) NA, #<<
    {
      glue::glue(
        "Average Beer Barrels Produced: {round(expr,2)}" #<<
      )
    },
    finally = { print("Thank God for Beer!") } #<<
  )
}
```

.pull-left[
```{r, eval=FALSE}
beer_mean_tryCatch(beer_mean_abort(beer_states, "state"))
```

```
[1] "Thank God for Beer!"
[1] NA
```

]

.pull-right[
```{r, eval=FALSE}
beer_mean_tryCatch(beer_mean_abort(beer_states, "barrels"))
```

```
[1] "Thank God for Beer!"
Average Beer Barrels Produced: 806.46
```

]

.footnote[
_I find it interesting that the `finally` statement is printed **before** the code inside the tryCatch. Can anyone explain why?_
]

---

# tryCatch

_We can use tryCatch within the for loop to catch errors without breaking the loop_

```{r, eval=FALSE}
for (indx in 1:ncol(beer_states)) {
    tryCatch(
        expr = {
            basic_summary_stats(beer_states, names(beer_states[indx]))
            message("Iteration ", indx, " successful.")
        },
        error = function(e){
            message("* Caught an error on itertion ", indx)
            print(e)
        }
    )
}
```

```
* Caught an error on itertion 1
<error/rlang_error>
Need numeric value to calculate stats and state is categorical
Backtrace:
 1. base::tryCatch(...)
 5. global::basic_summary_stats(beer_states, names(beer_states[indx]))
* Caught an error on itertion 2
<error/rlang_error>
Need numeric value to calculate stats and year is categorical
Backtrace:
 1. base::tryCatch(...)
 5. global::basic_summary_stats(beer_states, names(beer_states[indx]))
round_n argument null, rounding to 2 digits by default
* Iteration 3 successful.
* Caught an error on itertion 4
<error/rlang_error>
Need numeric value to calculate stats and type is categorical
Backtrace:
 1. base::tryCatch(...)
 5. global::basic_summary_stats(beer_states, names(beer_states[indx]))
```

---

class: inverse, hide-logo

# withCallingHandlers
A story in three functions. 

---

# withCallingHandlers
### Function 1

```{r, eval=FALSE}
simple_mean <- function(x) {
  if(!is.numeric(x)) {
    
    abort(
      "categorical_column",
      message = "Not sure what to do with categorical column",
      x = x
    )
    
  }
  cat("Returning from simple_mean() \n")
  return(mean(x[which(!is.na(x))]))
}
```


.pull-left[
#### Success

```{r, eval=FALSE}
simple_mean(beer_states$barrels)
```

```
Returning from simple_mean()
[1] 2286370
```
]

.pull-right[
#### Failure

```{r, eval=FALSE}
simple_mean(beer_states$states)
```
```
Error in simple_mean(beer_states$states) : 
  Not sure what to do with categorical column
```
]

---

# withCallingHandlers
#### Function 2

```{r, eval=FALSE}
# use restart to just get the length of categorical columns
mean_count <- function(y) {
  as_count <- withRestarts(simple_mean(y),
                        # establish a restart called 'categorical_column'
                        # which returns the negative of it's argument
                        categorical_column_restart = function (z) { length(z) } )
  cat("Returning from mean_count() \n")
  return(as_count)
}
```

.pull-left[
#### Success

```{r, eval=FALSE}
mean_count(beer_states$barrels)
```

```
Returning from simple_mean()
Returning from mean_count()
[1] 2286370
```
]

.pull-right[
#### Failure

```{r, eval=FALSE}
mean_count(beer_states$states)
```
```
Error in simple_mean(beer_states$states) : 
  Not sure what to do with categorical column
```
]

---

# withCallingHandlers
#### Function 3

```{r, eval=FALSE}
mean_or_count <- function(z){
  as_mean_or_count <- withCallingHandlers(
    # call mean or count function
    mean_count(z),
    # and if an `error` occurrs
    error = function(err) {
      # and the `error` is a `categorical_column` error
      if(inherits(err,"cateogircal_column")) {
        # invoke the restart called 'categorical_column_restart'
        invokeRestart('categorical_column_restart',
                      # and invoke it with this parameter
                      err$x)
      } else {
        # otherwise re-raise the error
        stop(err)
      }
    })
  cat("Returning from mean_or_count()\n")
  return(as_mean_or_count)
}
```

.pull-left[
#### Success

```{r, eval=FALSE}
mean_or_count(beer_states$barrels)
```

```
Returning from simple_mean()
Returning from mean_count()
Returning from mean_or_count()
[1] 2286370
```
]

.pull-right[
#### Failure

```{r, eval=FALSE}
mean_or_count(beer_states$states)
```
```
Error in simple_mean(beer_states$states) : 
  Not sure what to do with categorical column
```
]

---

```{r, echo=FALSE}
tibble(
  Function = c(
    "signalCondition",
    "simpleCondition",
    "simpleError",
    "simpleWarning",
    "simpleMessage",
    "errorCondition",
    "warningCondition",
    "conditionCall",
    "conditionMessage",
    "withRestarts",
    "computeRestarts",
    "findRestart",
    "invokeRestart",
    "invokeRestartInteractively",
    "isRestart",
    "restartDescription",
    "restartFormals",
    "suspendInterrupts",
    "allowInterrupts"
  ),
  Definition = c(
    "", "", "", "", "", "", "",
    "return sthe message of a condition",
    "returns the call of a condition",
    "establishes recovery protocols",
    "returns a list of all restarts",
    "returns the most recently established restart of the specified name",
     "", "", "", "", "", "", "")
) %>%
  gt() %>%
  tab_options(table.font.size = 9, row.striping.background_color = "red") %>%
    cols_width(
    vars(Function) ~ px(150),
    vars(Definition) ~px(500)
  ) %>%
  cols_align(
    align = "right",
    columns = vars(Function)
  ) %>%
  tab_header(
    title = md("Other [base] Condition Functions"),
    subtitle = md("R Documentation")
    )
```



<style>
pre {
  font-size: 11px;
}

.small-font {
  font-size: 13px;
}

.footnote {
  color: #800020;
}

</style>