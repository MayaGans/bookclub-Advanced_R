# 17 Big Picture

```{r, include=FALSE}
library(dplyr)
library(magrittr)
```

:::question
How would you succinctly define meta-programming - I want to say its "code that writes code"....? But I also want to say its what allows you to specify columns as their names without quotes, but I don't quite understand how to tie that into "code that writes code"
:::

Metaprogramming is using code as data. And data as code if you put the data together the right way. 

So how does that translate into specifying columns without quotes? You’re treating code as data and not actually evaluating it until you’re in a different context where the names used in the code/expressions have meanings they don’t have in the current context.

Conceptualizing code as data you get to do data-centric things like modifying it, passing it to other functions, applying your own conventions for how to read the data etc


:::question
Hadley uses VERY cautious wording, saying that calling meta-programming NSE is "sloppy" but the two terms seem highly related. How do we untangle them?
:::

Taken from the [lazyeval vignette](https://cran.r-project.org/web/packages/lazyeval/vignettes/lazyeval.html#metaprogramming)

> The final use of non-standard evaluation is to do metaprogramming. This is a catch-all term that encompasses any function that does computation on an unevaluated expression. You can learn about metaprogrgramming in http://adv-r.had.co.nz/Expressions.html, particularly http://adv-r.had.co.nz/Expressions.html#ast-funs. Over time, the goal is to move all useful metaprogramming helper functions into this package, and discuss metaprogramming more here.

The sloppiness is referring to NSE *functions* when it actually the function arguments that use NSE. The dplyr vignette says:

> "Tidy evaluation is a special type of non-standard evaluation used throughout the tidyverse." and says it is used in two ways in dplyr: data masking and tidy selection.

A great resource on lazyeval: https://arxiv.org/abs/1909.08958

:::question
I love the idea of creating templates then shoving in code using `!!` can we create a template that inserts a filtering statement into our tidypipeline?

```{r, eval=FALSE}
# this is my template
iris %>%
  ggplot2::ggplot() +
  ggplot2::aes(x = Sepal.Length, y = Sepal.Width) + 
  ggplot2::geom_point()
# somehow insert this into the template at line 2
dplyr::filter(Sepal.Length > 4.5) %>%
# to create something prettier than 
if (x == 2) {
  iris %>%
    dplyr::filter(Sepal.Length > 4.5) %>%
    ggplot2::ggplot() +
    ggplot2::aes(x = Sepal.Length, y = Sepal.Width) + 
    ggplot2::geom_point()
} else {
  iris %>%
    ggplot2::ggplot() +
    ggplot2::aes(x = Sepal.Length, y = Sepal.Width) + 
    ggplot2::geom_point()
}
```
:::

```{r}
customizable_iris <- function(pipeline_insertion = NULL){
  dt <- rlang::expr(iris)
  pi <- rlang::enexpr(pipeline_insertion)
  if (!rlang::is_null(pi))
    dt <- rlang::expr(!!dt %>% !!pi)
  rlang::expr(
    !!dt %>%  
      ggplot2::ggplot() +
      ggplot2::aes(x = Sepal.Length, y = Sepal.Width) + 
      ggplot2::geom_point()
  )
}
(x <- customizable_iris(dplyr::filter(Sepal.Length > 5)))
rlang::eval_bare(x)
```

Any valid r code can be converted into an expression or list of expressions, and expressions can be patched together using this unquoting (forcing) procedure. 

Probably best thoguht of in terms of the tree structure, by replacing one node with another expression:

```{r}
lobstr::ast(a + b)
```

```{r}
b <- rlang::expr(x + y)
lobstr::ast(!!b)
lobstr::ast(a + !!b)
```

so the forcing operation is kind of like performing surgery on the AST, where you cut out one node (the thing being forced) and replacing it with some other code.
