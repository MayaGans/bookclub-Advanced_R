# S3

```{r, include=FALSE}
library(sloop)
```

## 13.1 Introduction {-}

:::question
> S3 is very flexible, which means it allows you to do things that are quite ill-advised

This sounds ominous, like what?
:::

:::TODO
:::

## 13.3 Classes {-}

:::question
Can we come up with a simple example for a `constructor`, `validator`, and `helper`?
:::

:::TODO

#### Constructor {-}

Create the custom class

```{#r}
```

#### Validator {-}

Function to make sure you can use your custom class

```{#r}
```

#### Helper {-}

Wrapper for constructor to make sure the validation checks pass

```{#r}
```
:::

## 13.3.4.3 Exercises {-}

:::question
Can we go over the factor source code, commenting it line for line?
:::

```{r, eval=FALSE}
# using the example:
x <- c("one", "two", "three", "one")

factor <- function (x = character(), levels, labels = levels, exclude = NA, ordered = is.ordered(x), nmax = NA) {
 
   # if character vector is null set to character()
  if (is.null(x)) 
      x <- character()
  # nx - names of x
  # in our case NULL
    nx <- names(x)
    # we didn't supply levels so it's missing
    if (missing(levels)) {
      # set y to the unique names found in the vector
      # nmax by default is NA but this is an argument
      # for unique setting the max number of unique values
        y <- unique(x, nmax = nmax)
        # get the order of the unique values
        # defaults to alphabetical
        ind <- order(y)
        # put our vector in order using only unique values
        levels <- unique(as.character(y)[ind])
    }
    # because the function arg is a promise 
    # we need to eval now to use it? I think?
    force(ordered) # FALSE
    # if x isn't a character string make it one
    if (!is.character(x)) 
        x <- as.character(x)
    # match the number of levels with NAs
    # then if they are NA it will resolve to TRUE
    # only return the TRUE levels
    # this is how we get rid of NAs!
    levels <- levels[is.na(match(levels, exclude))]
    # get the ordered levels
    f <- match(x, levels)
    # if the names aren't null give f those names
    if (!is.null(nx)) 
        names(f) <- nx
    # if missing levels make levels back into a character string?
    # why?
    if (missing(labels)) {
        levels(f) <- as.character(levels)
    }
    # otherwise get the legenth of your labels
    # if its the same as the levels
    else {
        nlab <- length(labels)
        if (nlab == length(levels)) {
            # xlevls is labels as character
            # then we get the unique values of that
            # and set that to xlevs
            nlevs <- unique(xlevs <- as.character(labels))
            # this is null
            at <- attributes(f)
            # attr levels
            at$levels <- nlevs
            # match the levels with ordered levels
            # and put the levels back in numeric order?
            # I think?
            f <- match(xlevs, nlevs)[f]
            # now set the attributes to the numeric levels
            attributes(f) <- at
        }
        # if you only have one lavel
        else if (nlab == 1L) 
            # add numerics to the end of the label?
            levels(f) <- paste0(labels, seq_along(levels))
            # otherwise invalid length
        else stop(gettextf("invalid 'labels'; length %d should be 1 or %d", 
            nlab, length(levels)), domain = NA)
    }
    # add ordered and factor to f's class list
    class(f) <- c(if (ordered) "ordered", "factor")
    f
}

factor(x)
```

## 13.3.4.4 Exercises {-}

:::question
Now that we've gone through the source code, I don't see where the contrasts attibute comes into play? We can look at the `C()` function but where is this used within `factor()`?
:::

:::TODO
:::

## 13.4.1 Generics {-}

:::question
In the example: 

```{r, eval=FALSE}
my_new_generic <- function(x) {
  UseMethod("my_new_generic")
}
```

The book states: "If you wonder why we have to repeat my_new_generic twice, think back to Section 6.2.3"

Can we go over why?
:::

:::TODO
:::

## 13.4.4.4 Exercises {-}

:::question
Can we explain what's happening here in our own words I was a little confused with the solutions manual? `g(x)` uses 1 from the `.default` method but `10` from the generic? Why?
:::

```{r, eval=FALSE}
g <- function(x) {
  x <- 10
  y <- 10
  UseMethod("g")
}

g.default <- function(x) c(x = x, y = y)

x <- 1
y <- 1
g(x)
```

```
 x  y 
 1 10 
```

:::TODO
:::

## 13.5 Object styles {-}

:::question
> Unfortunately, describing the appropriate use of each of these object styles is beyond the scope of this book. 

Can we use the `vctrs` package in a concrete example to address some of these fringe cases and reasons why `length(x)` is causing an issue?
:::

:::TODO
:::

## 13.5.1.1 Exercise {-}

:::question
Categorise the objects returned by lm(), factor(), table(), as.Date(), as.POSIXct() ecdf(), ordered(), I() into the styles described above.
:::

:::TODO
:::

## 13.6 Inheritance {-}

:::question
Can we make our own example of a method with inheritance?
:::

:::TODO
:::

## 13.6.2 Subclassing {-}

:::question
Can we in our own words break down what `vctrs::vec_restore` is doing for us? How does `...` allow us to keep the right class on the output?
:::

:::TODO
:::

## 13.4.3.3

:::question
Can we go over why this doesn't return `a1`? 
:::

```{r, eval=FALSE}
generic2 <- function(x) UseMethod("generic2")
generic2.a1 <- function(x) "a1"
generic2.a2 <- function(x) "a2"
generic2.b <- function(x) {
  class(x) <- "a1"
  NextMethod()
}

generic2(structure(list(), class = c("b", "a2")))
```

```
[1] "a2"
```


## 13.7.1 S3 and Base Types {-}


:::question
What exactly is meant by "implicit class"?
:::

:::TODO
:::


:::question
WHY isn't the dispatch of mean(x1) determined by its type???
:::

```{r, eval=FALSE}
x1 <- 1:5
class(x1)
```

```
[1] "integer"
```

```{r, eval=FALSE}
s3_dispatch(mean(x1))
```

```
   mean.integer
   mean.numeric
=> mean.default
```

:::TODO
:::

## 13.7.3 Internal Generics {-}


:::question
> Defining a single group generic for your class overrides the default behaviour for all of the members of the group.

Does this mean that if I define abs for my class it overrides the behaviour of sign, sqrt and all the others in the Math group?
:::

Essentially, these are all (loosely) math-related functions, so R understands how to do these for anything it can understand as a numeric (somehow). If you're adding a class that isn't handled in one of these numeric-ish ways, you'll need to tell R how to handle the mathematics. You can't make a group like "Math", "Ops", "Summary", or "Complex" and expect R to know what it's doing.

If you define `abs` for your class it won't know how to do the other things. Suppose you defined your own `min.POSIXct` then when you call `min(Sys.time())` it will encounter your function, evaluate, and then that is the end.  Otherwise, min would call the min Primitive which is implemented in C [as found here](https://github.com/wch/r-source/blob/bf4cf8912596162a3ae5a2b7da1a74220105b172/src/main/summary.c#L520) and if you trace through that you will see that is where the `GroupDispatch` is called.

## 13.7.4 Double Dispatch {-}

:::question
What is happening here:
```{r, eval=FALSE}
Ops.foo <- function(...)  print("Called twice for some reason?")
x <- structure(2, class = "foo")
x > 0
```

```
[1] "Called twice for some reason?"
[1] "Called twice for some reason?"
```
:::

Double dispatch -- where itâ€™s calling the same method on x and zero. The inequality needs to convert both to the same class.

:::question
The book mentions that we can use `vctrs::vec_arith` to avoid the aboce, but does that pertain to this case? I tried: `vctrs::vec_arith(">", x, 0)` But I think my understanding is still off...
:::

The `vec_arith` generic will first dispatch on `class(x)` So, in this case it tries to find `vec_arith.foo` but we haven't defined that yet, so it instead finds `vec_arith.default` which signals the error.

```{r, eval=FALSE}
x <- structure(2, class = "foo")
x > 0
```

```
[1] TRUE
```

```{r, eval=FALSE}
vec_arith(">", x, 0) 
```

```
Error: <foo> > <double> is not permitted
vec_arith will dispatch to this first, because it finds the "foo" generic
```

```{r, eval=FALSE}
vec_arith.foo <- function(op, x, y, ...) {
  # now it will dispath on y, which in this case is a numeric.
  UseMethod("vec_arith.foo", y)
}
vec_arith(">", x, 0) 
```

```
Error in UseMethod("vec_arith.foo", y): no applicable method for 'vec_arith.foo' applied to an object of class "c('double', 'numeric')"
```

Uh oh another error, and this is super confusing because none of our objects are class double.  (typeof(x) is "double"). The problem is that vec_arith.foo further dispatches on the second argument and it is looking for `vec_arith.numeric` or `vec_arith.default`, but we haven't defined that yet.

```{r, eval=FALSE}
vec_arith.foo.numeric <- function(op, x, y, ...) {
  vctrs::vec_arith_base(op, x, y, ...)
}
vec_arith(">", x, 0)
```

```
[1] TRUE
```

```{r, eval=FALSE}
vec_arith(">", 0, x)
```

```
Error: <double> > <foo> is not permitted
```

now vec_arith will first dispatch on the 0 and scope to vec_arith.numeric which will then try to dispatch to vec_arith.numeric.foo which we havent defined yet.

```{r, eval=FALSE}
vec_arith.numeric.foo <- function(op, x, y, ...) {
  vctrs::vec_arith_base(op, x, y, ...) 
}
vec_arith(">", 0, x)
```

```
[1] FALSE
```

:::question
What is happening here?!
:::

```{r, eval=FALSE}
Math.bar <- function(x) {
  print("Math bar")
  NextMethod(.Generic)
}

Math.foo <- function(x) {
  print("Math foo")
  NextMethod(.Generic)
}

x <- 1
class(x) <- c("foo", "bar", class(x))
abs(x)

`abs.foo` <- function(x) {
  print("Generic foo")
  NextMethod()
}
abs(x)

`abs.bar` <- function(x) {
  print("Generic bar")
  NextMethod()
}

abs(x)
rm(abs.foo)
# infinite recursion continually calling abs.bar, only calling Math.foo once
abs(x)
rm(Math.foo)
# back to working
abs(x)
```

:::TODO
:::
