[
["environments.html", "Chapter 7 Environments 7.2.3 Parents 7.2.4 Super assignment 7.2.5 Getting and setting 7.2.6 Advanced bindings 7.3 Recursing over environments 7.3.1.2 Exercises 7.4.2 Function enviornment 7.4.3 Namespaces 7.5 Call stacks 7.6 Data Structures", " Chapter 7 Environments 7.2.3 Parents What’s the relationship between base, empty enviornment, and global enviornment? The global environment is your working enviornment, where all packages loaded are its parent. When you list the parents of the gloal environment the last environment is always base which is responsible for loading all other packages. The base’s parent is the “ultimate ancestor”, the empty enviornment. Clarification: the global environment’s parent is all the packages loaded within the environment, not the empty environment, right? How do we check this? parent.env(global)? Each package becomes a parent to the global environment. We can inspect local enviornments using search_envs() search_envs() ## [[1]] $ &lt;env: global&gt; ## [[2]] $ &lt;env: package:openintro&gt; ## [[3]] $ &lt;env: package:rlang&gt; ## [[4]] $ &lt;env: package:lobstr&gt; ## [[5]] $ &lt;env: package:kableExtra&gt; ## [[6]] $ &lt;env: package:forcats&gt; ## [[7]] $ &lt;env: package:stringr&gt; ## [[8]] $ &lt;env: package:dplyr&gt; ## [[9]] $ &lt;env: package:purrr&gt; ## [[10]] $ &lt;env: package:readr&gt; ## [[11]] $ &lt;env: package:tidyr&gt; ## [[12]] $ &lt;env: package:tibble&gt; ## [[13]] $ &lt;env: package:ggplot2&gt; ## [[14]] $ &lt;env: package:tidyverse&gt; ## [[15]] $ &lt;env: package:stats&gt; ## [[16]] $ &lt;env: package:graphics&gt; ## [[17]] $ &lt;env: package:grDevices&gt; ## [[18]] $ &lt;env: package:utils&gt; ## [[19]] $ &lt;env: package:datasets&gt; ## [[20]] $ &lt;env: package:methods&gt; ## ... and 2 more environments 7.2.4 Super assignment Let’s expand on the concept of super assignment x &lt;- 0 f &lt;- function() { x &lt;- 2 x &lt;&lt;- 1 x } f() ## [1] 2 x ## [1] 1 Note that the assignment inside f is local, but super assignment “never creates a variable in the current environment” so it modifies the global x and not the local x. If you want to break your brain a bit, check out: x &lt;- 0 f &lt;- function() { x &lt;- x x &lt;&lt;- x + 1 x } f() ## [1] 0 x ## [1] 1 f() ## [1] 1 x ## [1] 2 f() ## [1] 2 x ## [1] 3 7.2.5 Getting and setting “But you can’t use [[ with numeric indices, and you can’t use [:” It makes sense to me that you can’t use numeric indexes because objects in an environment aren’t ordered, but why can’t you use [? The solutions manual states: &quot;The second option would return two objects at the same time. What data structure would they be contained inside? [ returns an object of the same type, if we were to apply this to environments we’d have an environment returning an environment. 7.2.6 Advanced bindings Hadley mentions delayed bindings are used when autoloading datasets with packages - can we find an example of this? How is this different from including LazyData: true in your description file? The LazyData: true entry in DESCRIPTION just informs that delayed binding should be used. autoload does use delayed bindings [from source code: do.call(&quot;delayedAssign&quot;, list(name, newcall, .GlobalEnv, .AutoloadEnv))] but lazydata that gets used by packages is ultimately implemented as an internal function. If you scan through View(loadNamespace): if (file.exists(paste0(dbbase, &quot;.rdb&quot;))) lazyLoad(dbbase, env) dbbase &lt;- file.path(pkgpath, &quot;data&quot;, &quot;Rdata&quot;) if (file.exists(paste0(dbbase, &quot;.rdb&quot;))) lazyLoad(dbbase, .getNamespaceInfo(env, &quot;lazydata&quot;)) and lazyLoad eventually calls .Internal(makeLazy(vars, vals, expr, db, envir)) which leads you to https://github.com/wch/r-source/blob/726bce63825844715860d35fdf76539445529f52/src/main/builtin.c#L103 and ultimately the delayed binding is realized as a promise with defineVar(name, mkPROMISE(expr0, eenv), aenv);. 7.3 Recursing over environments How can we re-write where so that it returns all functions with the same name? where2 &lt;- function(in_name, env = caller_env()) { all_functions &lt;- &quot;&quot; index &lt;- 1 while (!identical(env, empty_env())) { # if success if (env_has(env, in_name)) { all_functions[index] &lt;- env_name(env) index &lt;- index + 1 #return() } # inspect parent env &lt;- env_parent(env) } # base case - I&#39;m missing this I think return(all_functions) } # load dplyr so you have two filters library(dplyr) where2(&quot;filter&quot;) ## [1] &quot;package:dplyr&quot; &quot;package:stats&quot; We can also create a function that emulates pryr’s where: where3 &lt;- function(name, env = parent.frame(), found = character()) { if (identical(env, emptyenv())) return(found) else if (exists(name, env, inherits = FALSE)) { Recall(name, parent.env(env), c(found, environmentName(env))) } else { Recall(name, parent.env(env), found) } } where3(&quot;filter&quot;) ## [1] &quot;package:dplyr&quot; &quot;package:stats&quot; 7.3.1.2 Exercises I understood the recursion in the prior example, but what is inherits doing here? Can we go through this line for line and discuss what is happening in this function? fget &lt;- function(name, env = caller_env(), inherits = TRUE) { # Base case if (env_has(env, name)) { obj &lt;- env_get(env, name) if (is.function(obj)) { return(obj) } } if (identical(env, emptyenv()) || !inherits) { stop(&quot;Could not find function called \\&quot;&quot;, name, &quot;\\&quot;&quot;, call. = FALSE) } # Recursive Case fget(name, env_parent(env)) } # Test mean &lt;- 10 fget(&quot;mean&quot;, inherits = TRUE) ## function (x, ...) ## UseMethod(&quot;mean&quot;) ## &lt;bytecode: 0x7f8a959e3400&gt; ## &lt;environment: namespace:base&gt; Inherits is an argument that stops the function from performing the recursive action of looking into the parent environment for the name. Inherits is acting like a valve. If false, and the name wasnt found in the current environment, then stop because the next expression searches the parent of env. In the case environment is the empty environment then stop because the empty environment doesnt have a parent. 7.4.2 Function enviornment I found this section a little confusing. Can we go over the second figure in the section? Where does x live? g points to x but x is in the global enviornment? Can we come up with our own example for a function being bound to the global environment but accessing variables from its own enviornment? (I think this is what the second figure in the section is trying to display) y &lt;- 1 e &lt;- env() e$g &lt;- function() 1 e$g ## function() 1 This can be seen in our where2 example in the recursion section! 7.4.3 Namespaces “Every binding in the package environment is also found in the namespace environment; this ensures every function can use every other function in the package. But some bindings only occur in the namespace environment. These are known as internal or non-exported objects, which make it possible to hide internal implementation details from the user.” When you’re developing a package does the namespace environment just come with your package for free when you build it or you need to create both your package and its namespace env? How do you create functions that exist only in the namespace environment? When you are building the package, everything in the NAMESPACE file gets generated by roxygen2. Attaching a package puts the package in the search path of namespaces. So when you run library(package) or require(package) it creates the namespace environment. Package developers control what names are available by exporting to namespace (and otherwise you can call non-exported with :::). For example let’s say you want to extend forcats to use ordered factors to lump the tails. In order to get it to work, we need to use some forcats helper functions. We could just copy the code for the functions and added them to our scripts, but for prototyping it’s easy enough to just use ::: fct_lump_ordered &lt;- function(f, n, prop, q, w = NULL, other_level_low = &quot;Other Low&quot;, other_level_high = &quot;Other High&quot;, ties.method = c(&quot;min&quot;, &quot;average&quot;, &quot;first&quot;, &quot;last&quot;, &quot;random&quot;, &quot;max&quot;)) { f &lt;- check_ordered(f) w &lt;- forcats:::check_weights(w, length(f)) ties.method &lt;- match.arg(ties.method) levels &lt;- levels(f) if (is.null(w)) { count &lt;- as.vector(table(f)) total &lt;- length(f) } else { count &lt;- as.vector(tapply(w, f, FUN = sum)) total &lt;- sum(w) } if (all(missing(n), missing(prop), missing(q))) { lump &lt;- forcats:::in_smallest(count) lump &lt;- lump_range(!lump) new_levels &lt;- ifelse(lump == -1L,other_level_low, ifelse(lump == 1L, other_level_high, levels)) } else if (!missing(n) ) { if (n &lt; 0) { rank &lt;- rank(count, ties = ties.method) n &lt;- -n } else { rank &lt;- rank(-count, ties = ties.method) } if (sum(rank &gt; n) &lt;= 1) { return(f) } lump &lt;- lump_range(rank &lt;= n) new_levels &lt;- ifelse(lump == -1L, other_level_low, ifelse(lump == 1L, other_level_high, levels)) } else if (!missing(prop)) { prop_n &lt;- count/total if(prop &lt; 0) { lump &lt;- lump_range(prop_n &lt;= -prop) new_levels &lt;- ifelse(lump == -1L, other_level_low, ifelse(lump == 1L, other_level_high, levels)) } else { if (sum(prop_n &lt;= prop) &lt;= 1) { return(f) } lump &lt;- lump_range(prop_n &gt;= prop) new_levels &lt;- ifelse(lump == -1L, other_level_low, ifelse(lump == 1L, other_level_high, levels)) } } else if (!missing(q)) { cdf &lt;- cumsum(count)/sum(count) lump &lt;- lump_range(cdf &gt;= q[1] &amp; cdf &lt;= q[2]) new_levels &lt;- ifelse(lump == -1L, other_level_low, ifelse(lump == 1L, other_level_high, levels)) } if (other_level_low %in% new_levels &amp;&amp; other_level_high %in% new_levels) { f &lt;- forcats::lvls_revalue(f, new_levels) forcats::fct_relevel(f, other_level_low) forcats::fct_relevel(f, other_level_high, after = Inf) } else if (other_level_low %in% new_levels) { f &lt;- forcats::lvls_revalue(f, new_levels) forcats::fct_relevel(f, other_level_low) } else if (other_level_high %in% new_levels) { f &lt;- forcats::lvls_revalue(f, new_levels) forcats::fct_relevel(f, other_level_high, after = Inf) } else { f } How do conflicted packages identify duplicate function names and print them out We can use conflict_scout! conflicted::conflict_scout ## function (pkgs = NULL) ## { ## pkgs &lt;- pkgs %||% pkgs_attached() ## objs &lt;- lapply(pkgs, pkg_ls) ## names(objs) &lt;- pkgs ## index &lt;- invert(objs) ## potential &lt;- Filter(function(x) length(x) &gt; 1, index) ## unique &lt;- Map(unique_obj, names(potential), potential) ## conflicts &lt;- Filter(function(x) length(x) &gt; 1, unique) ## conflicts &lt;- map2(names(conflicts), conflicts, superset_principle) ## conflicts &lt;- map2(names(conflicts), conflicts, drop_moved) ## for (fun in ls(prefs)) { ## if (!has_name(conflicts, fun)) ## next ## conflicts[[fun]] &lt;- prefs_resolve(fun, conflicts[[fun]]) ## } ## conflicts &lt;- compact(conflicts) ## new_conflict_report(conflicts) ## } ## &lt;bytecode: 0x7f8a9d51bc18&gt; ## &lt;environment: namespace:conflicted&gt; 7.5 Call stacks What exactly is a frame? A frame is a singular step within the CST - in thr following example, f, g, and h are each frames f &lt;- function(x) { g(x = 2) } g &lt;- function(x) { h(x = 3) } h &lt;- function(x) { stop() } 7.6 Data Structures Can we discuss what’s happening in this function? Since it’s similar to the setwd function from last week could we build on this function to include on.exit()? my_env &lt;- new.env(parent = emptyenv()) my_env$a &lt;- 1 get_a &lt;- function() { my_env$a } set_a &lt;- function(value) { old &lt;- my_env$a my_env$a &lt;- value invisible(old) } We can use those two functions like we did getting and setting the work directory inside another function - using the old value within on.exit to reset my_env$a outside of the function cleanup(value) { my_env_a &lt;- get_a() set_a(value) # now we can do stuff with the new my_env$a value on.exit(set_a(my_env_a), add=TRUE) } The bullet point mentions hashmaps but I’m still really unclear on what that is. What are hash tables and are they related? They are sort of like fast look-up tables! It may be impossible to show with a small example. To demonstrate that the lookup is fast you’d need to store a lot of stuff in it first. You’d also probably need an alternative implementation of a lookup table to compare it to. We could probably implement a hash table relatively easily* using environments. Demonstrating that using environments is a good way to do it seems difficult. looking at a data structures textbook (Cormen, Lieserson &amp; Rivest), a hash table is expected to provide users with fast functions for insert, search, and delete. "]
]
