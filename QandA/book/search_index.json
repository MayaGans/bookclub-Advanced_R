[
["functions.html", "Chapter 6 Functions 6.2.2 Primitives 6.2.5.1 Exercises 6.3 Function composition 6.4 Lexical scoping 6.4.3 A fresh start 6.5 Lazy evaluation 6.5.1 Promises 6.5.2 Default arguments 6.5.4.3 Exercise 6.5.4.4 Exercise 6.6 dot dot dot 6.6.1.2 Exercise 6.7.4 Exit handlers 6.7.5.4 Exercise 6.7.5.5 Exercise 6.8.4 Replacement functions 6.8.6.3 Exercise", " Chapter 6 Functions 6.2.2 Primitives So if you are familiar with C can you just write a function in C in R? What does that process look like? I think this is a bigger question of digging into the relationship between C and R. We can use RCPP! Rcpp::cppFunction(&#39;#include&lt;string&gt; std::string IPA() { std::string val = &quot;IPAs suck&quot;; return val; }&#39;) val &lt;- IPA() val ## [1] &quot;IPAs suck&quot; 6.2.5.1 Exercises This question is flagged as “started” let’s try to complete it! Q: Given a name, like &quot;mean&quot;, match.fun() lets you find a function. Given a function, can you find its name? Why doesn’t that make sense in R? A: A name can only point to a single object, but an object can be pointed to by 0, 1, or many names. What are names of the functions in the following block? function(x) sd(x) / mean(x) ## function(x) sd(x) / mean(x) f1 &lt;- function(x) (x - min(x)) / (max(x) - min(x)) f2 &lt;- f1 f3 &lt;- f1 There isn’t a 1 to 1 mapping between functions and names in R. Multiple names may point to the same function as we see for f1, f2, and f3. Also, each function has its own environment so it’s possible that two functions might have the same “code” but are not the same because they have different environments (or closures). Lastly, anonymous functions don’t have names so we’d have no way to look these up. That said…. we could find the names of our functions if they are all in the global environment: names(which(sapply(mget(lsf.str()), function(x) body(x) == body(function(x) (x - min(x)) / (max(x) - min(x)))))) ## [1] &quot;f1&quot; &quot;f2&quot; &quot;f3&quot; But I don’t think this scales when functions are outside of the global environment e1 &lt;- rlang::env(f1 = function(x) (x - min(x)) / (max(x) - min(x))) e2 &lt;- rlang::env(f2 = function(x) (x - min(x)) / (max(x) - min(x))) 6.3 Function composition When comparing nested, intermediate, and piping functions, it looks like Hadley flips the order of f() and g() between bullet points It does look like he does that! f &lt;- function(z) { cat(&quot;g is:&quot;, z) } g &lt;- function(x) { x * 2 } 6.0.1 Nested f(g(2)) ## g is: 4 6.0.2 Intermediate This is written in the book as y &lt;- f(x); g(y) but should be flipped to y &lt;- g(x); f(y) if we are to follow the nested example y &lt;- g(2) f(y) ## g is: 4 6.0.3 Piping This also needs to be flipped from x %&gt;% f() %&gt;% g() to x %&gt;% g() %&gt;% f() 2 %&gt;% g() %&gt;% f() ## g is: 4 6.4 Lexical scoping “The scoping rules use a parse-time, rather than a run-time structure”? What is “parse-time” and “run-time”? How do they differ? parse-time is when the function gets defined: when the formals and body get set. run-time is when it actually gets called. This function doesn’t get past parse-time because of the syntax error get_state &lt;- function(in_df, state_name){ out_df % in_df[in_df$state == state_name, ] return(out_df) } get_state &lt;- function(in_df, state_name){ out_df % in_df[in_df$state == state_name, ] Error: unexpected input in: &quot;get_state &lt;- function(in_df, state_name){ out_df % in_df[in_df$state == state_name, ]&quot; return(out_df) Error: object &#39;out_df&#39; not found } Error: unexpected &#39;}&#39; in &quot;}&quot; This function will get parsed successfully but could fail at run at run-time if the input data frame doesn’t have a column named state: get_state &lt;- function(in_df, state_name){ out_df &lt;- in_df[in_df$state == state_name, ] return(out_df) } get_state(iris, &#39;setosa&#39;) ## [1] Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;0 rows&gt; (or 0-length row.names) At R’s build-time, if you want to run a function from a package that isn’t loaded it will not throw an error but at run-time it will if the required package is not loaded: func_1 &lt;- function(df, x) { select({{ df }}, {{ x }}) } test_tbl &lt;- tibble::tibble(x1 = runif(5), x2 = rnorm(5), x3 = rpois(5, lambda = 1)) Without dplyr this will fail func_1(test_tbl, x1) Error in select({: could not find function &quot;select&quot; This will work: library(dplyr) #&gt; #&gt; Attaching package: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union func_1(test_tbl, x1) ## # A tibble: 5 x 1 ## x1 ## &lt;dbl&gt; ## 1 0.742 ## 2 0.120 ## 3 0.253 ## 4 0.563 ## 5 0.240 6.4.3 A fresh start How would we change this code so that the second call of g11() is 2? g11 &lt;- function() { if (!exists(&quot;a&quot;)) { a &lt;- 1 } else { a &lt;- a + 1 } a } g11() ## [1] 1 g11 &lt;- function() { if (!exists(&quot;a&quot;)) { a &lt;- 1 } else { a &lt;- a + 1 } a &lt;&lt;- a a } g11() ## [1] 1 6.5 Lazy evaluation “This allows you to do things like include potentially expensive computations in function arguments that will only be evaluated if needed” Does anyone have an example of this? We discussed a function that will only perform expensive tasks given the context of the function perhaps? Maybe a situation where we can give a function default arguments where sampleis a stand in for longer expensive functions like different fancy modeling techniques? We can workshop this… mega_model &lt;- function(values, x = sample(1:100, 10), y = sample(200:300, 10), z = sample(300:400, 10) ) { dplyr::case_when( is.numeric(values) ~ x, is.character(values) ~ y, TRUE ~ z ) } mega_model(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## [1] 207 277 242 266 265 299 295 213 243 281 6.5.1 Promises Can we discuss the order that this happening in? Is it that Calculating... is printed, then x*2 then x*2 again? I am still reading this as: h03(double(20), double(20)) which is an incorrect mental model because the message is only printed once… double &lt;- function(x) { message(&quot;Calculating...&quot;) x * 2 } h03 &lt;- function(x) { c(x, x) } Explain what’s happeining here below in words, and restructure the promise image to make more sense double &lt;- function(y) { message(&quot;Calculating...&quot;) cat(&quot;double before\\n&quot;) print(pryr::promise_info(y)) force(y) cat(&quot;double after\\n&quot;) print(pryr::promise_info(y)) y * 2 } h03 &lt;- function(x) { cat(paste0(&quot;h03 before\\n&quot;)) print(pryr::promise_info(x)) force(x) cat(&quot;h03 after\\n&quot;) print(pryr::promise_info(x)) c(x, x) } double(h03(20)) ## Calculating... ## double before ## Registered S3 method overwritten by &#39;pryr&#39;: ## method from ## print.bytes Rcpp ## $code ## h03(20) ## ## $env ## &lt;environment: R_GlobalEnv&gt; ## ## $evaled ## [1] FALSE ## ## $value ## NULL ## ## h03 before ## $code ## [1] 20 ## ## $env ## &lt;environment: R_GlobalEnv&gt; ## ## $evaled ## [1] FALSE ## ## $value ## NULL ## ## h03 after ## $code ## [1] 20 ## ## $env ## NULL ## ## $evaled ## [1] TRUE ## ## $value ## [1] 20 ## ## double after ## $code ## h03(20) ## ## $env ## NULL ## ## $evaled ## [1] TRUE ## ## $value ## [1] 20 20 ## [1] 40 40 plop &lt;- function(a, b) a * 10 plop(2, var_doesnt_exist) ## [1] 20 var_doesnt_exist is a promise within g, we use the promises within g when we call f but f never uses its second argument so this runs without a problem. When would we want to leverage this behavior? The unevaluated var_doesnt_exist doesn’t exist , but we can use substitute to to get the expression out of a promise! If we modify our function we can play with the expression contained in b: plop &lt;- function(a, b) { cat(&quot;You entered&quot;, deparse(substitute(b)), &quot;as `b` \\n&quot;) a * 10 } plop(a = 2, b = var_doesnt_exist) ## You entered var_doesnt_exist as `b` ## [1] 20 We can even evaluate b and use it to create a dplyr like pull function: plop &lt;- function(a, b) { eval(substitute(b), envir = a) } plop(iris, Species)[1:10] ## [1] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa ## Levels: setosa versicolor virginica 6.5.2 Default arguments I don’t quite understand why x = ls() is different from ls() here; aren’t we still assigning x = ls() but without specifying x? h05 &lt;- function(x = ls()) { a &lt;- 1 x } # this makes sense to me h05() ## [1] &quot;a&quot; &quot;x&quot; # how is this different from above? h05(ls()) ## [1] &quot;a&quot; &quot;double&quot; &quot;f&quot; &quot;f1&quot; &quot;f2&quot; ## [6] &quot;f3&quot; &quot;func_1&quot; &quot;g&quot; &quot;g11&quot; &quot;get_state&quot; ## [11] &quot;h03&quot; &quot;h05&quot; &quot;IPA&quot; &quot;mega_model&quot; &quot;plop&quot; ## [16] &quot;test_tbl&quot; &quot;val&quot; &quot;y&quot; The difference is where the promise is created. ls() is always evaluated inside h05 when x is evaluated. The difference is the environment. When ls() is provided as an explicit parameter, x is a promise whose environment is the global environment. When ls() is a default parameter, it is evaluated in the local environment where it is used. Hypothesis: does nesting ls() in h05 first evaluate ls() then evaluate h05() ? library(magrittr) h05 &lt;- function(x = {y &lt;- 4;ls()}) { a &lt;- 1 x } h05() [1] &quot;a&quot; &quot;x&quot; &quot;y&quot; ls() [1] &quot;h05&quot; {y &lt;- 4;ls()} %&gt;% h05() [1] &quot;h05&quot; &quot;y&quot; ls() [1] &quot;h05&quot; &quot;y&quot; h05({x &lt;- 5;ls()}) [1] &quot;h05&quot; &quot;x&quot; &quot;y&quot; ls() [1] &quot;h05&quot; &quot;x&quot; &quot;y&quot; Notice in all of the latter calls, a is not returned - so it’s not evaluating ls() inside of the function. 6.5.4.3 Exercise I understand this problem is showing us an example of name masking (the function doesn’t need to use the y = 0 argument because it gets y from within the definition of x, but I’m fuzzy on what exactly the ; does. What does the syntax {y &lt;- 1; 2} mean? Could it be read as &quot;Set y &lt;- 1 and x &lt;- 2? y &lt;- 10 f1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) { c(x, y) } f1() ## [1] 2 1 The curly brackets are an expression, which can be read as { y &lt;- 1 2 } ## [1] 2 This is returning 2 and setting 1 to y. The colon can be read as a new line in the expression. x is called inside the function and overwrites the argument value of y f1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) { # At this point, neither x nor y have been needed or evaluated. This is &quot;lazy&quot;. cat(y) # &quot;Summon the current state of y&quot;. # R looks first in the function env - is there a y there? No # R then looks at the arguments - is there a y there? Yes, it&#39;s 0 -&gt; print out zero # If R had not found y in the arguments, then it would look in the parent environment of the function - the global env. # That&#39;s where it would find y = NULL - but since it already found a default arg, it already stopped evaluating. cat(x) # &quot;Summon the current state of x&quot; # x is an expression that first sets y to equal 1 and then returns the number 2 -&gt; print out 2 c(x, # &quot;Summon the current state of x&quot; - x is still the expression that sets y to 1 and then x to 2 y) # &quot;Summon the current state of y&quot; - y was set to 1, so y is 1 here. } f1() ## 02 ## [1] 2 1 Compare to: f1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) { c(y, # &quot;Summon the current state of y&quot; - y has not yet been set to anything else, so it returns zero x) # &quot;Summon the current state of x&quot; - x is still the expression that sets y to 1 and then x to 2 # However, y has already been returned - so even though y is now set to 1, it&#39;s called after the previous y and does not affect the previous y. } x = NULL y = NULL f1() ## [1] 0 2 6.5.4.4 Exercise I know this isn’t exactly needed to answer the question, but how do we access a function that has methods? For instance - here I want to dig into the hist function using hist hist ## function (x, ...) ## UseMethod(&quot;hist&quot;) ## &lt;bytecode: 0x7fe2618f0e40&gt; ## &lt;environment: namespace:graphics&gt; does not give me the actual contents of the actual function…. We need to access is using hist.&lt;method&gt; hist.default 6.6 dot dot dot “(See also rlang::list2() to support splicing and to silently ignore trailing commas…” Can we come up with a simple use case for list2 here? The docs use list2(a = 1, a = 2, b = 3, b = 4, 5, 6) but how is this different from list? identical( rlang::list2(a = 1, a = 2, b = 3, b = 4, 5, 6) , list(a = 1, a = 2, b = 3, b = 4, 5, 6) ) ## [1] TRUE list2 is most helpful when we need to force environment variables with data variables. We can see this by creating a function that takes a variable number of arguments: library(rlang) numeric_list &lt;- function(...) { dots &lt;- list(...) num &lt;- as.numeric(dots) set_names(num, names(dots)) } numeric_list2 &lt;- function(...) { dots &lt;- list2(...) num &lt;- as.numeric(dots) set_names(num, names(dots)) } numeric_list(1, 2, 3) ## [1] 1 2 3 numeric_list2(1, 2, 3) ## [1] 1 2 3 The main difference with list(…) is that list2(…) enables the !!! syntax to splice lists: x &lt;- list(2, 3) numeric_list2(1, !!! x, 4) ## [1] 1 2 3 4 numeric_list(1, !!! x, 4) Error in !x : invalid argument type “lapply() uses ... to pass na.rm on to mean()” Um, how? x &lt;- list(c(1, 3, NA), c(4, NA, 6)) str(lapply(x, mean, na.rm = TRUE)) ## List of 2 ## $ : num 2 ## $ : num 5 An lapply takes on two main arguments: what you want to loop over and the function to apply to each element. By including ... lapply allows you to supply additional arguments which will be passed to the function inside the lapply. In this case, na.rm = TRUE is being applied to mean every time it’s being called in the loop. 6.6.1.2 Exercise I tried running browser(plot(1:10, col = &quot;red&quot;)) to peek under the hood but only got Called from: top level in the console. What am I missing? We can use debugonce! debugonce(plot()) 6.7.4 Exit handlers “Always set add = TRUE when using on.exit() If you don’t, each call to on.exit() will overwrite the previous exit handler.” What does this mean? add = TRUE is important when you have more than one on.exit function! j08 &lt;- function() { on.exit(message(&quot;a&quot;)) on.exit(message(&quot;b&quot;), add=TRUE) } j08() ## a ## b Can we go over this code? How does it not change your working directory after you run the function cleanup &lt;- function(dir, code) { old_dir &lt;- setwd(dir) on.exit(setwd(old_dir), add = TRUE) old_opt &lt;- options(stringsAsFactors = FALSE) on.exit(options(old_opt), add = TRUE) } cleanup(&quot;~&quot;) getwd() ## [1] &quot;/Users/mayagans/Documents/bookclub-Advanced_R/QandA&quot; The behavior of setwd “changing the working directory” is actually a side effect of the function - it invisibly returns the previous working directory as the value of the function (potentially for the exact purpose demonstrated). We can use this within our on.exit function to change back to the prior working directory! If on.exit fails will it continue onto the next on.exit so long as add == TRUE ?``on.exit fails it’ll continue onto the next one f &lt;- function() { on.exit(stop(&quot;Error&quot;)) on.exit(message(&quot;yay, still called.&quot;), add = TRUE) } f() Error in f() : Error yay, still called. 6.7.5.4 Exercise This question is flagged as “started” let’s try to complete it! Hadley comments in the repo: “I think I’m more interested in supplying a path vs. a logical value here”. Q: How does the chdir parameter of source() compare to in_dir()? Why might you prefer one approach to the other? The in_dir() approach was given in the book as in_dir &lt;- function(dir, code) { old &lt;- setwd(dir) on.exit(setwd(old)) force(code) } A: in_dir() takes a path to a working directory as an argument. First the working directory is changed accordingly. on.exit() ensures that the modification to the working directory are reset to the initial value when the function exits. In source() the chdir argument specifies if the working directory should be changed during the evaluation of the file argument (which in this case has to be a path name). XXX 6.7.5.5 Exercise Can we go over the source code of capture.output and capture.output2? There were several new terms here to me when going over this function: stderr error output stdout normal output #!/usr/bin/env Rscript # redirect.r -- experiments with warning and error messages # Get any arguments (and ignore them) arguments &lt;- commandArgs(trailingOnly=TRUE) # Default write(&quot;1) write() to stderr&quot;, stderr()) write(&quot;1) write() to stdout&quot;, stdout()) warning(&quot;1) warning()&quot;) # Ignore all warnings options(warn = -1) write(&quot;2) write() to stderr&quot;, stderr()) write(&quot;2) write() to stdout&quot;, stdout()) warning(&quot;2) warning()&quot;) # Send all STDERR to STDOUT using sink() options(warn = 0) # default setting sink(stdout(), type=&quot;message&quot;) write(&quot;3) write() to stderr&quot;, stderr()) write(&quot;3) write() to stdout&quot;, stdout()) warning(&quot;3) warning()&quot;) # Send all STDOUT to STDERR using sink() sink(NULL, type=&quot;message&quot;) # default setting sink(stderr(), type=&quot;output&quot;) write(&quot;4) write() to stderr&quot;, stderr()) write(&quot;4) write() to stdout&quot;, stdout()) warning(&quot;4) warning()&quot;) # Send messages and output to separate files msg &lt;- file(&quot;message.Rout&quot;, open=&quot;wt&quot;) out &lt;- file(&quot;output.Rout&quot;, open=&quot;wt&quot;) sink(msg, type=&quot;message&quot;) sink(out, type=&quot;output&quot;) write(&quot;5) write() to stderr&quot;, stderr()) write(&quot;5) write() to stdout&quot;, stdout()) warning(&quot;5) warning()&quot;) sink diverts R output to a connection. zz &lt;- file(&quot;all.Rout&quot;, open = &quot;wt&quot;) sink(zz) sink(zz, type = &quot;message&quot;) try(log(&quot;a&quot;)) ## Error in log(&quot;a&quot;) : non-numeric argument to mathematical function ## revert output back to the console -- only then access the file! sink(type = &quot;message&quot;) sink() file.show(&quot;all.Rout&quot;) textConnection allows R character vectors to be read as if they were being read from a text file. They can capture R output to a character vector They can be used to create a new character object or append to an existing one in the user’s workspace. At all times the complete lines output to the connection are available in the R object. Closing the connection writes any remaining output to a final element of the character vector. function (..., file = NULL, append = FALSE, type = c(&quot;output&quot;, &quot;message&quot;), split = FALSE) { # Capture dots # [-1L] removes the list() args &lt;- substitute(list(cat(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;\\n&quot;)))[-1L] # match type &lt;- match.arg(type) # set default return value rval &lt;- NULL # set default closer closeit &lt;- TRUE # if file is null, then if (is.null(file)) # If file is null, then create a write-only text connection object which will # save to the variable rval in the execution environment (local = TRUE). # see https://biostatmatt.com/R/R-conn-ints.pdf for gritty info on connections (and sinks) file &lt;- textConnection(&quot;rval&quot;, &quot;w&quot;, local = TRUE) else if (is.character(file)) # if &quot;file&quot; is a character vector, then interpret it as a filename. Open a # file connection in either append or write mode, depending on the value of # &quot;append&quot; file &lt;- file(file, if (append) &quot;a&quot; else &quot;w&quot;) else if (inherits(file, &quot;connection&quot;)) { # if &quot;file&quot; is already a connection object, check if it is open. If not, open it # in append mode, if specified, otherwise in write mode. # inherits refers to the S3 class system. # # Browse[2]&gt; class(file) # [1] &quot;textConnection&quot; &quot;connection&quot; if (!isOpen(file)) open(file, if (append) &quot;a&quot; else &quot;w&quot;) # if the connection is already open, don&#39;t close it in this function. else closeit &lt;- FALSE } # if you get here, then you misspecified &quot;file&quot; else stop(&quot;&#39;file&#39; must be NULL, a character string or a connection&quot;) # sink all output of type &quot;type&quot; into the connection &quot;file&quot;. If you would like # the output to continue to its original source, then &quot;split&quot; it. # # by default, messages (messages, warnings, errors) go to stderr and # everything else to stdout. sink(file, type = type, split = split) on.exit({ # on exit, call sink with the same arguments and without &quot;file&quot; being specified. # this will cause the sink from the line before to terminate. sink(type = type, split = split) # Close the connection (always, unless &quot;file&quot; was provided as # an already open connection) if (closeit) close(file) }) # store the calling environment in pf. i.e. pf refers to the environment in # which capture.output was called. pf &lt;- parent.frame() # define a local function which will evaluate its sole argument (expr) in the # parent frame. evalVis &lt;- function(expr) withVisible(eval(expr, pf)) # for each argument collected in the dot dot dot. # # use split = TRUE to help you debug at this point. When you try to poke around # with the sink applied, you are rightfully stymied because all output is going # to the sink connection! for (i in seq_along(args)) { # store the argument in expr expr &lt;- args[[i]] # based on the mode of the expr, evaluate it. tmp &lt;- switch(mode(expr), expression = lapply(expr, evalVis), call = , name = list(evalVis(expr)), stop(&quot;bad argument&quot;)) # print any visible values output during evaluation. # This print will be collected by the sink we set up earlier and saved to # the file connection. for (item in tmp) if (item$visible) print(item$value) } # calling on.exit with no arguments will clear the exit handler. # we are doing this because the on.exit was designed to safeguard the sink # and files being closed in the case of an exception when evaluating the # passed in arguments. on.exit() # undo the sink sink(type = type, split = split) # close the file if necessary if (closeit) close(file) # return the captured output or null invisibly otherwise. if (is.null(rval)) invisible(NULL) else rval } capture.output2 &lt;- function(code) { temp &lt;- tempfile() on.exit(file.remove(temp), add = TRUE) sink(temp) on.exit(sink(), add = TRUE) force(code) readLines(temp) } The second function will always sink output to a temporary file, and then return the results by reading the file back in (and returning a character vector). It uses two exit handlers, one to clean up the temporary file, and one to remove the sink. 6.8.4 Replacement functions Can we put into words the translation for x &lt;- c(a = 1, b = 2, c = 3) names(x) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; names(x)[2] &lt;- &quot;two&quot; names(x) ## [1] &quot;a&quot; &quot;two&quot; &quot;c&quot; Being equal to `*tmp*` &lt;- x x &lt;- `names&lt;-`(`*tmp*`, `[&lt;-`(names(`*tmp*`), 2, &quot;two&quot;)) rm(`*tmp*`) We can dig into the source code, but the jist is that in order to implement these complex assignments: Copy x into a temporary variable *temp* [&lt;-(names(*tmp*), 2, &quot;two&quot;) modifies the second element of the names of *temp*, names&lt;-(*tmp* assigns step 2 to *temp* names Clean up by removing the temp variable 6.8.6.3 Exercise This question is flagged as “started” let’s try to complete it! Q: Explain why the following code fails: ```r modify(get(&quot;x&quot;), 1) &lt;- 10 #&gt; Error: target of assignment expands to non-language object ``` A: First, let’s define x and recall the definition of modify() from the textbook: ```r x &lt;- 1:3 `modify&lt;-` &lt;- function(x, position, value) { x[position] &lt;- value x } ``` XXX "]
]
